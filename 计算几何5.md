<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=28484894&auto=1&height=66"></iframe>

如果有一天拥抱的温度可以找到它永远的主人。 如果有一天白色的云与蓝色的苍穹颠倒了颜色。 如果有一天紫罗兰在盛放之前就呈现出它最美的花瓣。 如果有一天世界上没有了风，没有了雨，没有了云，没有了梦，没有了声音，没有了爱恋，没有了你。

文章目录:

[TOC]

# 旋转卡壳

## 引入

我们之前讨论过了平面最近点对的$O(nlogn)$做法, 那我们考虑一下**平面最远点对**的做法.
首先暴力枚举复杂度是$O(n^2)$这个就不用说了.
我们联想到刚刚学习过的凸包.
很显然平面最远点对上的点都是凸包上的点. 
我们枚举凸包上的点就能做到$O(H^2)$了.
这个在平均情况下是可以过的.
但是刻意卡一卡还是$O(n^2)$的.

考虑优化.

很容易发现, 最远点对寻找的是凸包的直径.
我们想象一下, 有一把游标卡尺紧紧卡住这个凸包, 要么贴住边要么卡住顶点, 围着凸包转一圈, 出现过的最大距离就是凸包的直径了. 也就是我们要求的平面最远点对的距离.

我们管这种东西叫[旋转卡壳](https://en.wikipedia.org/wiki/Rotating_calipers). 
四个多音字. 共有$2*3*2*2=24$种可能的读音.
可怕的是"旋转"中"转"的读音都不能得到公认...
不过好像是读$zhu\check an$的多一些..
所以最后的读法应该是$xu\acute an\ zhu\check an\ qi\check a\ k\acute e$???
算了不重要...我们还是应该更关心是怎么个实现法.

## 分析

其实这个旋转卡壳的gif是很毒的, 我觉得大家都应该看一下, 所以就盗了一张图(滑稽)
![](http://img.blog.csdn.net/20160305153623628)

我们将被一对卡壳正好卡住的对对应点称为**对踵点(Antipodal point)**.
可以证明对踵点的个数不超过$\frac3 2$个, 也就是$O(n)$级别的.

那么如何找对踵点呢?
我们发现卡壳的情况有3种

1. 卡住凸包的两个点.
   ![Case1](http://img.blog.csdn.net/20180106211410289?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRW56eW1paQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

2. 卡住凸包的一个点和一条边.
   ![Case2](http://img.blog.csdn.net/20180106211538906?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRW56eW1paQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

3. 特殊情况: 卡住凸包的一对平行边.
   ![Case3](http://img.blog.csdn.net/20180106211518085?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRW56eW1paQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

   其中的第一种情况并不好处理, 我们主要考虑第二种, 而第三种则可以视为第二种的一种特殊情况.
   我们考虑枚举边, 然后找与这个边距离最远的点. 将这个点与边的两个端点的距离取个最大值即可.
   与边的距离我们就考虑三角剖分. 因为底边是定的(要枚举的), 所以高就与面积挂钩, 而面积直接用叉积就可以求了.. 又是凸多边形, 面积一定是正的..
   但这看上去还是$O(n^2)$的啊..

   我们就需要考虑凸包优美的性质了.
   比如面积是单峰的.
   ![](http://img.blog.csdn.net/20180106212759663?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRW56eW1paQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

   底一样了 高显然是单峰的, 所以面积也就是单峰的了.
   所以我们枚举到点$i$时, 如果$i+1$对应的三角形的面积比$i$小, 我们就不需要枚举了.
   不过这一分析好像暂时还并没有实质上影响到复杂度.

   我们继续观察, 枚举下一条边.

   ![](http://img.blog.csdn.net/20180106213505131?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRW56eW1paQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

   我们发现随着边的旋转, 距离最远的点不可能是刚才得到的最远点(绿)前面的点(红). 其实这也挺显然的.. 于是我们只需要从上一次找到的最高点开始枚举即可..
   这样复杂度就降下来了.

##代码

有一道[板子题](https://www.luogu.org/problemnew/show/P1452)... Emmmm...
所以就贴一下完整的实现代码 (然而到了poj还是WA不知道为啥...

```c++
#include <cmath> 
#include <cstdio>
#include <algorithm>
const int N=50101;
const double eps=1e-9;
int dcmp(const double &a){
    if(fabs(a)<eps)return 0;
    return a<0?-1:1;
}
inline double max(const double &a,const double &b){return dcmp(a-b)>0?a:b;}
struct point{
    double x,y;
    point(const double &X=0,const double &Y=0):x(X),y(Y){}
}p[N],stk[N];int tp,mi;
point operator -(const point &a,const point &b){
    return point(a.x-b.x,a.y-b.y);
}
double operator ^(const point &a,const point &b){
    return a.x*b.x+a.y*b.y;
}
double operator *(const point &a,const point &b){
    return a.x*b.y-a.y*b.x;
}
double len(const point &a){
    return sqrt(a^a);
}
//bool cmpa(const point &a,const point &b){
//	point X=point(1,0),A=a-p[0],B=b-p[0];
//	double coa=(A^X)/len(A),cob=(B^X)/len(B);
//	return dcmp(coa-cob)>0;
//} //按夹角排序(点积版)
bool cmpa(const point &a,const point &b){
  	point A=a-p[0],B=b-p[0];
  	if(!dcmp(A*B)) return dcmp(len(A)-len(B))>0;
  	return dcmp(A*B)>0;
} //叉积版 
void grahamScan(point* p,int n){
    std::sort(p+1,p+n,cmpa);
    stk[++tp]=p[0]; stk[++tp]=p[1];
    for(int i=2;i<n;++i){
        while(dcmp((p[i]-stk[tp])*(stk[tp]-stk[tp-1]))>=0&&tp>2) --tp; //顺时针就退栈 
        stk[++tp]=p[i]; //进栈
    }
}
double rotatingCalipers(){
    int j=2; stk[tp+1]=stk[1]; double ans=-1e9;
    for(int i=1;i<=tp;++i){
        while(dcmp((stk[j+1]-stk[i])*(stk[i+1]-stk[i])-(stk[j]-stk[i])*(stk[i+1]-stk[i]))<0){ //这里的面积是负的哟~所以用的是小于..
            ++j; if(j>tp) j=1;
        }
        ans=max(ans,max(len(stk[j]-stk[i]),len(stk[j]-stk[i+1])));
    }
    return ans;
}
int main(){
    int n; scanf("%d",&n); double my=1e9;
    for(int i=0;i<n;++i){
        scanf("%lf%lf",&p[i].x,&p[i].y);
        if(dcmp(p[i].y-my)<0||
        (!dcmp(p[i].y-my)&&dcmp(p[i].x-p[mi].x)<0))
            my=p[i].y,mi=i;	
    } std::swap(p[0],p[mi]);
    grahamScan(p,n);
    double a=rotatingCalipers();
    printf("%.0lf",a*a);
}
```



看上去非常麻烦~~读起来也非常麻烦~~的旋转卡壳写起来却只需要这么几行(说的是rotatingCalipers那个函数), 这就非常厉害了.

当然了, 旋转卡壳不仅仅可以用来求凸多边形的直径, 它的用途非常非常的广泛.

##用途

### 凸多边形直径

#### 分析

可以直接抄上面的求凸包直径...

#### 代码

```cpp
double diameterOfConvex(point* p,int n){
    int j=1; stk[n]=stk[0]; double ans=-1e9;
    for(int i=1;i<=tp;++i){
        while(dcmp((p[j+1]-p[i])*(p[i+1]-p[i])-(p[j]-p[i])*(p[i+1]-p[i]))<0){
            ++j; if(j>tp) j=1;
        }
        ans=max(ans,max(len((p[j]-p[i]),len(p[j]-p[i+1])));
    }
    return ans;
}
```



### 凸多边形宽

#### 分析

凸多边形的宽定义为平行切线的**最小**距离.
切线的话方向非常多, 但是要求最小的话, 我们不需要每个方向都检测.
![](http://img.blog.csdn.net/20180107111414158?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRW56eW1paQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

很明显的, 如果这组平行线只卡住两个点(红), 我们总可以旋转一个角度, 使其中一条平行线与一条边重合, 从而找到更小的距离.

这很显然就是旋转卡壳的形式.
我们枚举每一条边, 找到距离最远的点时, 计算点到对边的距离, 然后找个最小值即可.
时间复杂度$O(n)$.

#### 代码

```c++
double widthOfConvex(point* p,int n){
	double ans=1e9; p[n]=p[0]; int j=1;
	for(int i=0;i<n;++i){
		while(dcmp((p[j]-p[i])*(p[i+1]-p[i])-(p[j+1]-p[i])*(p[i+1]-p[i]))<0){
			++j; if(j==n) j=0;
		}
		ans=min(ans,fabs(p[j]*(p[i+1]-p[i])/len(p[i+1]-p[i])));
	}
	return ans;
}
```

### 凸多边形间最小距离

#### 分析

这道题是有板子题的~[戳这里查看..](http://poj.org/problem?id=3608)
讲道理

给定两个凸多边形$A$和$B$, 要求找到两个点$M,N$, 满足$M\in A,N\in B$,求$|MN|_{min}$

当然这个是有前提的, 就是两个凸多边形**不连接**(比如不相交). 因为两个凸多边形的距离如果小于0的话根据定义最小距离自然就是0了, 这显然没什么意思.

事实上, 这个问题更为常见一些, 比如用来做碰撞检测(距离降为0)之类的, 所以理应有更多的算法. 似乎网上是能找到更多的解决方案的.

而今天的主角是**旋转卡壳**, 所以我们只说说旋转卡壳的做法.

首先很显然地, 我们可以发现最小距离的点对一定是在多边形的外部, 但并不一定在顶点上.
![](http://poj.org/images/3608_1.gif)

比如这张图上的点对中的一个就不是顶点, 而是红线和蓝线的交点.

我们让旋转的卡壳分别卡两个多边形..
我们枚举一个多边形的边, 然后从另一个多边形中找合适的对应点.
与上面不同的是, 因为要求距离最小, 所以找三角形面积**最小**的.

不过更新距离的时候要注意, 要分别更新每一条线段两个端点的到另一条线段的距离, 也就是4个距离取最小值防止遗漏. 就是说线段$AB$与线段$CD$的距离为
$d=min(dis(A,CD),dis(B,CD),dis(C,AB),dis(D,AB))$.

#### 代码

因为有板子题所以贴完整代码
~~其实交这个题的过程是很曲折的 而且baidu上有很多题解会WA...~~

```c++
#include <cmath>
#include <cstdio>
#include <algorithm>
const int N=1e4+10;
const double eps=1e-9;
int dcmp(const double &a){
	if(fabs(a)<eps) return 0;
	return a<0?-1:1;
}
struct point{
	double x,y;
	point(double X=0,double Y=0):x(X),y(Y){}
}p1[N],p2[N]; int y1min,y2min,y2max;
point operator -(const point &a,const point &b){return point(a.x-b.x,a.y-b.y);}
double operator *(const point &a,const point &b){return a.x*b.y-a.y*b.x;}
double operator ^(const point &a,const point &b){return a.x*b.x+a.y*b.y;}
inline double len(const point &a){return sqrt(a^a);}
inline double max(const double &a,const double &b){return dcmp(a-b)>0?a:b;}
inline double min(const double &a,const double &b){return dcmp(a-b)<1?a:b;}
inline void anticlockwise_sort(point *p,int n)  {  
    for(int i=0;i<n-2;++i)  {  
        double tmp=(p[i+2]-p[i])*(p[i+1]-p[i]);
		if(dcmp(tmp)<0) return;
		else if(dcmp(tmp)>0){
			for(int i=0;i<n/2;++i){
				point t=p[i];
				p[i]=p[n-1-i];
				p[n-1-i]=t;
			}
		}
    }  
} 
double ptDisSeg(const point &p,const point &a,const point &b){
	if(dcmp((p-a)^(b-a))<0) return len(p-a);
	if(dcmp((p-b)^(a-b))<0) return len(p-b);
	return fabs((p-a)*(b-a))/len(b-a);
}
double minDisSegs(const point &a,const point &b,const point &c,const point &d){
	return min(min(ptDisSeg(c,a,b),ptDisSeg(d,a,b)),min(ptDisSeg(a,c,d),ptDisSeg(b,c,d)));
}
double minDistOfConvexs(point* p1,point *p2,int n1,int n2){
	int j=0; double ans=1e9;
	p1[n1]=p1[0]; p2[n2]=p2[0];
	for(int i=0;i<n1;++i){
		while(dcmp((p2[j]-p1[i])*(p1[i+1]-p1[i])-(p2[j+1]-p1[i])*(p1[i+1]-p1[i]))>0){
			++j; if(j==n2) j=0;
		}
		ans=min(ans,minDisSegs(p1[i],p1[i+1],p2[j],p2[j+1]));
	}
	return ans;
}
int main(){
	int n,m;
	while(~scanf("%d%d",&n,&m)&&(n||m))
    {  
        for(int i=0;i<n;++i)  
            scanf("%lf%lf",&p1[i].x,&p1[i].y);  
        for(int i=0;i<m;++i)  
            scanf("%lf%lf",&p2[i].x,&p2[i].y);  
        anticlockwise_sort(p1,n);  
        anticlockwise_sort(p2,m); 
        printf("%.5f\n",minDistOfConvexs(p1,p2,n,m));
    }
}

```

### 凸多边形间最大距离

#### 分析

分析完最小距离我们来说一下最大距离.

很明显, 这两个点不可能在凸多边形内.

一种很显然的想法是, 将两个凸包合并成一个大凸包, 然后求直径.
我们现在已经可以用$O(nlogn)$的时间复杂度完成这个任务了.
不过凸包的合并(在后面可能会学)好像是可以做到$O(n)$复杂度的. 
不过好像也是利用了旋转卡壳的做法.

我们考虑能不能直接用旋转卡壳做.
由于可以等价为找大凸包上的对踵点, 所以用普通的旋转卡壳大约就可以做了.
枚举一个多边形的每一条边, **从另一个多边形中**找距离最大的点, 然后用两个端点的距离的最大值更新即可.

#### 代码

原理跟上面的都是大同小异的, 稍微拼一拼就出来了, 注意一下细节就ok了.

```c++
double maxDistOfConvexs(point* p1,point *p2,int n1,int n2){
	int j=0; double ans=-1e9;
	p1[n1]=p1[0]; p2[n2]=p2[0];
	for(int i=0;i<n1;++i){
		while(dcmp((p2[j]-p1[i])*(p1[i+1]-p1[i])-(p2[j+1]-p1[i])*(p1[i+1]-p1[i]))<0){
			++j; if(j==n2) j=0;
		}
		ans=max(ans,max(len(p2[j]-p1[i+1]),len(p2[j]-p1[i])));
	}
	return ans;
}
```

这两个用途表示旋转卡壳不仅可以卡**一个凸多边形**, 还可以卡**两个凸多边形**, 进而解决一些问题.

其他用途以后再学..